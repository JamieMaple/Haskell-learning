# æ„é€ æˆ‘ä»¬è‡ªå·±çš„ç±»å‹ä¸ç±»å‹ç±»

## å®šä¹‰æ–°çš„æ•°æ®ç±»å‹

``` haskell
-- å·¦ç«¯ä¸ºç±»å‹åç§°ï¼Œå³ç«¯ä¸ºå€¼æ„é€ å™¨ï¼ˆvalue constructorï¼‰
data Bool = False | True
    deriving (Show)
```

1. ç±»å‹åå’Œå€¼æ„é€ å™¨çš„é¦–å­—æ¯å¿…é¡»å¤§å†™

2. å€¼æ„é€ å™¨æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªè¿”å›æŸæ•°æ®ç±»å‹çš„å‡½æ•°

3. å€¼æ„é€ å™¨ä¹Ÿå¯ä»¥è¿›è¡Œæ¨¡å¼åŒ¹é…

4. å¯¼å‡ºæ•°æ®ç±»å‹ï¼š

``` haskell
module moduleName
( Type(Sub1, Sub2)
, Type(..)
, Type
) where
```

æ‹¬å·ä¸­å¯ä»¥å¯¼å‡ºå€¼æ„é€ å™¨ï¼Œä¹Ÿå¯ä»¥å¯¼å‡ºæ‰€æœ‰ï¼Œä¹Ÿå¯ä»¥ä¸å¯¼å‡ºå€¼æ„é€ å™¨ï¼Œå†…éƒ¨å®ç°è¿›

æ¯”å¦‚ `Data.Map` çš„ç±»å‹å°±æ²¡æœ‰å¯¼å‡ºä»»ä½•å€¼æ„é€ å™¨

## è®°å½•è¯­æ³•

ç”¨äºæ„é€ å­—æ®µæ¯”è¾ƒå¤šåˆä¸å®¹æ˜“åˆ†è¾¨çš„åœ°æ–¹ï¼ŒåŒæ—¶ä¸å…³å¿ƒå­—æ®µçš„é¡ºåºå’Œä½ç½®

ä¸ä»…æ–¹ä¾¿ä»£ç çš„é˜…è¯»ï¼Œä¹Ÿæ›´ä¼˜é›…ï¼Œå¯ä»¥è‡ªåŠ¨ç”Ÿæˆå‡½æ•°ï¼Œæ ¹æ®å­—æ®µå–å€¼

``` haskell
data Person = Person { firstName :: String
    , lastName                   :: String
    , age                        :: Int
    , height                     :: Int
    , phoneNumber                :: String
    , flavor                     :: String } deriving (Show)
```

## ç±»å‹æ„é€ å™¨

> ç±»å‹æ„é€ å™¨å–ç±»å‹ä½œä¸ºå‚æ•°å¹¶äº§ç”Ÿæ–°çš„ç±»å‹ï¼ˆğŸ¤”å¯èƒ½ç±»ä¼¼äºæ³›å‹ï¼‰

``` haskell
data Maybe a = Nothing | Just a
-- è¿™é‡Œçš„ a å°±æ˜¯ä¸€ä¸ªç±»å‹å‚æ•°
-- | ä»£è¡¨æˆ–
```

æ˜¾å¼ï¼š`Just 3 :: Int`

`Nothing` ç±»å‹æ˜¯ `Maybe a` æ‰€ä»¥å®ƒæ˜¯å¤šå°çš„ç±»å‹


> ç„¶è€Œåœ¨ haskell ä¸­æœ‰ä¸€é¡¹ä¸¥æ ¼çš„çº¦å®šï¼Œé‚£å°±æ˜¯æ°¸è¿œä¸è¦åœ¨ data ä¸­æ·»åŠ ç±»çº¦æŸ

## æ´¾ç”Ÿç±»å‹

> ç±»å‹ç±»æ›´åƒæ˜¯æ¥å£ï¼Œè€Œéä¼ ç»Ÿ OOP ç±»çš„è“å›¾

1. å®ç° `Eq`ï¼šä¼šå…ˆæ£€æŸ¥å€¼æ„é€ å™¨æ˜¯å¦ä¸€è‡´ï¼Œç„¶åæ£€æŸ¥å…¶ä¸­æ¯ä¸€å¯¹å­—æ®µæ•°æ®æ˜¯å¦ç›¸ç­‰

2. å®ç° `Read` å’Œ `Show`ï¼š`Show` ç±»å‹å¯ä»¥è®©æ´¾ç”Ÿç±»èƒ½å¤Ÿåœ¨å±å¹•ä¸Šæ‰“å°å‡ºæ¥ï¼Œ`Read` ç±»å‹èƒ½ä»å­—ç¬¦ä¸²ä¸­**é€šè¿‡ç±»å‹æ³¨é‡Š** è½¬åŒ–æˆæƒ³è¦çš„ç±»å‹

3. å®ç° `Ord`ï¼šå¯¹äºæ‹¥æœ‰å¤šä¸ªå€¼æ„é€ å™¨çš„ç±»å‹ï¼Œå®šä¹‰åœ¨å‰é¢çš„æ›´å°

    æ‰€ä»¥ `True` > `False`ï¼Œ`Maybe` ç±»ä¹Ÿå¯ä»¥æ¯”è¾ƒå¤§å°ï¼Œ`Nothing` æœ€å°

    ä½†æ˜¯å‡½æ•°æ— æ³•æ¯”è¾ƒå¤§å°ï¼Œå¹¶ä¸æ˜¯ `Ord` ç±»çš„å®ä¾‹

4. `Bounded` `Enum` ç­‰

``` haskell
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
    deriving (Eq, Ord, Show, Read, Bounded, Enum)
-- æ‰€æœ‰å€¼æ„é€ å™¨éƒ½æ˜¯ç©ºå…ƒï¼ˆnullaryï¼‰
```

`Enum` ç±»å‹ï¼š`succ` è·å¾—åç»§ï¼Œ`prev` è·å–å‰é©±

## ç±»å‹åˆ«å

1. `[Char]` å’Œ `String` ç­‰ä»·å°±æ˜¯åŸºäºç±»å‹åˆ«å

``` haskell 
type String = [Char]
```

åº”å½“æ³¨æ„çš„æ˜¯ haskell ä¸­ç±»å‹åˆ«åå¹¶ä¸ä¼šåˆ›é€ æ–°ç±»å‹ï¼Œ`data` åˆ›å»ºæ–°ç±»å‹

2. å‚æ•°åŒ–ç±»å‹åˆ«å

``` haskell 
type AssocList k v = [(k,v)]

findVal :: (Eq k) => k -> AssocList k v -> Maybe v

type IntMap = AssocList Int -- æŸ¯é‡ŒåŒ–éƒ¨åˆ†åº”ç”¨
```

æ³¨ï¼šç±»å‹æ„é€ å™¨ä¸å€¼æ„é€ å™¨æ˜¯ä¸ä¸€æ ·çš„

æ‰€ä»¥ä»¥ä¸‹ä¸æ­£ç¡®

``` haskell
Float 1
AssocList [(1,2)]
```

è€Œåº”å½“è¿™æ ·

``` haskell
1 :: Float
[(1,2)] :: AssocList Int Float
```

ç±»å‹åˆ«ååªèƒ½åœ¨ Haskell çš„ç±»å‹éƒ¨åˆ†åœ¨ä½¿ç”¨ã€‚ç±»å‹éƒ¨åˆ†åŒ…æ‹¬äº† `data`ã€`type` ä»¥åŠ `ç±»å‹å£°æ˜(::)`

2. `Either`

``` haskell
data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)
-- ä¸€èˆ¬ Left çš„ç±»å‹è¡¨ç¤ºé”™è¯¯çš„ç±»å‹ï¼Œè€Œ Right ä»£è¡¨æ­£ç¡®çš„
```

## é€’å½’æ•°æ®ç»“æ„

1. Listï¼ˆå½¢å¦‚é“¾è¡¨ï¼‰

``` haskell
data List a = Empty | Cons a (List a) deriving (Eq, Read, Show, Ord)

-- equal to
data List a = Empty | Cons { ListHead :: a, ListTail :: List a } deriving (Eq, Read, Show, Ord)
```

å…¶ä¸­ `Empty` ç›¸å½“äº `[]`ï¼Œ`Cons` ç›¸å½“äº `:`

``` haskell
-- å®ç°æ ‡å‡†åº“çš„ List
infixr 5 :
data List a = Empty | a : (List a) deriving (Show, Read, Eq, Ord)

infixr 5 ++
(++) :: List a -> List a -> List a
Empty  ++ ys = ys
(x:xs) ++ ys = (:) x (xs ++ ys)
```

æ¨¡å¼åŒ¹é…æœ¬è´¨ä¸Šå°±æ˜¯å¯¹å€¼æ„é€ å™¨çš„åŒ¹é…ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥å¯¹ä¸€äº›åŸºæœ¬å€¼è¿›è¡Œå€¼æ„é€ å™¨çš„åŒ¹é…

2. æ ‘å½¢ç»“æ„

``` haskell
-- binary search tree
data Tree a = EmptyTree | Node (Tree a) (Tree a) deriving (Show)
```

æ³¨ï¼šhaskell çš„æ•°æ®ç»“æ„ä¸èƒ½åƒ c ç­‰æŸäº›è¯­è¨€é‚£æ ·ä½¿ç”¨ç›´æ¥ä½¿ç”¨æŒ‡é’ˆï¼Œhaskell åªæœ‰å€¼

æ ‘çš„ä¸€äº›åˆ—æ“ä½œä¸åƒå…¶ä»–è¯­è¨€é‚£æ ·ï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªæ–°æ ‘ï¼ˆpurityï¼‰ï¼Œè¿™æ ·å¹¶ä¸ä½æ•ˆï¼Œå› ä¸ºåº•å±‚æœ‰ä¼˜åŒ–


## ç±»å‹ç±»

1. Eq ç±»å‹ç±»ï¼š

``` haskell
-- å®šä¹‰ä¸€ä¸ªæ–°ç±»å‹ç±» Eqï¼Œå…¶ä¸­ a ä¸ºç±»å‹å˜é‡
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
-- å‡½æ•°ä½“çš„å®ç°æ˜¯å¯é€‰çš„ï¼Œå¿…é¡»è¦çš„æ˜¯ç±»å‹å£°æ˜
-- å‡½æ•°ä½“çš„æ˜¯ä»¥äº¤å‰é€’å½’å®ç°çš„
-- è¯¥ç§é£æ ¼è¢«ç§°ä¸ºç±»å‹ç±»çš„æœ€å°å®Œå¤‡å®šä¹‰
-- å‡½æ•°ä½“å¹¶éå‡½æ•°çš„å®é™…ç±»å‹
```

2. æ‰‹å·¥å®ç°ç±»å‹ç±»

``` haskell
instance <Class> <Type> where
-- implementation
```

`Show` ç±»å‹çš„æœ€å°å®Œå¤‡å®šä¹‰è¦æ±‚å®ç° `show` å‡½æ•°

3. å­ç±»åŒ–

``` haskell
-- ç±»å‹çº¦æŸï¼Œæ›´æ˜¯å­ç±»åŒ–
class (Eq a) => Num a where
```

4. ä½œä¸ºç±»å‹å®ä¾‹çš„å¸¦å‚æ•°ç±»å‹

``` haskell
instance (Eq m) => Eq (Maybe m) where
    ....
```

æŸ¥çœ‹æŸä¸ªç±»å‹ç±»çš„å®šä¹‰ä»¥åŠå®ä¾‹ï¼š`:info {type}`ï¼Œå¯¹ç±»å‹å’Œç±»å‹æ„é€ å™¨éƒ½æœ‰æ•ˆ

## Yes-No ç±»å‹ç±»

Haskell ä¸¥æ ¼æ£€æŸ¥ Boolï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥å®ç°æœ‰ä¸€ç§ç±»ä¼¼ JS çš„å¸ƒå°”éšå¼ç±»å‹è½¬åŒ–åŠŸèƒ½

``` haskell
class YesNo a where
    yesno :: a -> Bool

instance YesNo Int where
    yesno 0 = False
    yesno _ = True

instance YesNo [a] where
    yesno [] = False
    yesno _ = True

instance YesNo Bool where
    yesno = id -- `id` æ˜¯æ ‡å‡†åº“å†…å°†å‚æ•°åŸæ ·è¿”å›çš„å‡½æ•°
-- ....
```



